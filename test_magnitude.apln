:Namespace test_magnitude
    Assert←#.unittest.Assert
    
    ⍝ evaluate each test with normal, empty and multiple shaped data
    ∇ tRes←tData Eval exp ;acR;acRE;exR;left;right;res;tID;tCmt;p
        (exR p)←exp
        (tID tCmt)←tData
        tRes←⍬

        ⍝ normal
        acR←|p ⍝ actual result
        res←exR≡acR
        tRes,←tData Assert res

        ⍝ ⍝ empty
        ⍝ acRE←|(0⍴⊂p) ⍝ generating empty array from right
        ⍝ res←⍬≡acRE ⍝ all 0s in exR is the new expected result
        ⍝ tRes,←('Empty',tID) tCmt Assert res

        ⍝ ⍝ different shapes
        ⍝ ⍝ for ANY array leftshape, and for any rightshape where (≢right)≤×/rightshape
        ⍝ ⍝ the condition guarantees that (rightshape⍴right) will create an array
        ⍝ ⍝ which contains ALL the elements of right, possibly more than once
        ⍝ leftshape←?⍳?7
        ⍝ ⍝ randomized shape which has ≤7 elements and each elements is ≤12 and satisfies above condition
        ⍝ rightshape←{(×/(x←(?7)?⍤/?12))>≢right:x ⋄ ∇⍵}⍬
        ⍝ res←(leftshape⍴exR) ≡ (leftshape⍴left)∊(rightshape⍴right)
        ⍝ tRes,←('Multiple',tID) tCmt Assert res
    ∇

    ∇ r←Test_Magnitude_General ;bool;i1;i2;i3;dbl;fl;Hdbl;Hfl;fr_dbl;fr_decf;getMagGen;case;data;d;testDesc;desc;fr
        bool←0 1                                      ⍝ 11: 1 bit Boolean type arrays
        i1←{⍵,-⍵}+⍳120                                ⍝ 83: 8 bits signed integer
        i2←{⍵,-⍵}10000+⍳1000                          ⍝ 163: 16 bits signed integer
        i3←{⍵,-⍵}100000+⍳100                          ⍝ 323: 32 bits signed  integer
        dbl←{⍵,-⍵}1000.5+⍳100                         ⍝ 645: 64 bits Floating
        ⎕FR←1287 ⋄ fl←{⍵,-⍵}1000.5+⍳100 ⋄ ⎕FR←645      ⍝ 1287: 128 bits Decimal
        ⍝ Hdbl is 645 but higher order to test for CT value
        ⍝ intervals of 2 are chosen because CT for these numbers +1 and -1
        ⍝ come under the region of tolerant equality
        Hdbl←{⍵,-⍵}1E14+(2×⍳50)
        ⍝ Hfl is 1287 but higher order to test for CT value
        ⍝ far intervals are chosen for non overlap 
        ⍝ with region of tolerant equality
        ⎕FR←1287 ⋄ Hfl←{⍵,-⍵}2E29+(1E16×⍳10) ⋄ ⎕FR←645 

        fr_dbl←645
        fr_decf←1287

        r←⍬
        getMagGen←{⍵<0:-1×⍵⋄⍵}
        testDesc←{'for ',case,' & ⎕CT ⎕DCT:',⎕CT,⎕DCT, '& ⎕FR:', ⎕FR}

        :For fr :In 1 2
            ⎕FR←fr⊃fr_dbl fr_decf
            :For case :In 'bool' 'i1' 'i2' 'i3' 'dbl' 'fl' 'Hdbl' 'Hfl'
                data←⍎case
                desc←testDesc⍬
                :If case≢'bool'
                    r,←'t1' desc Eval ({⍵,⍵}{((≢⍵)÷2)↑⍵}data) data
                    d←data[?≢data]
                    r,←'t2' desc Eval (getMagGen d) d
                :Else
                    r,←'tb1' desc Eval (0 1) bool
                    r,← 'tb2' desc Eval 0 (⊃bool)
                :EndIf
            :EndFor
        :EndFor
    ∇

    ∇ r←Test_Magnitude_Cmplx ;cmplx;Hcmplx;getMagCmplx;c
        cmplx←{⍵,-⍵}(0J1×⍳10)+⌽⍳10            ⍝ 1289: 128 bits Complex
        Hcmplx←{⍵,-⍵}(1E14J1E14×⍳20)          ⍝ 1289 but higher order to test for CT value
        
        getMagCmplx←{*∘0.5+/2*⍨(9 11○⊂⍵)}
        r←⍬
        :For c :In cmplx⍝, Hcmplx
            r,←'tc1' ('for' c) Eval (getMagCmplx c) c
        :EndFor
        ⍝ r,←'tc2' 'for cmplx' Eval (getMagCmplx¨cmplx) |cmplx
    ∇
:EndNamespace