:Namespace union_and_intersection
    Assert←#.unittest.Assert
    ints←#.utils.ints
    doSlowTests←#.utils.doSlowTests

    ⍝ Models are not in use but kept for reference
    ⍝ model←{⍺,(∧/⍺≢¨⍵)/⍵}
    ⍝ modelUnion←{⍺,(~⍵∊⍺)/⍵}
    modelUnion←{⍺,⍵~⍺}
    modelIntersection←{(⍺∊⍵)/⍺}

    ∇ r←testDesc
      r←'for ',case,{0∊⍴case2:'',⍵ ⋄ ' , ',case2,⍵},' & ⎕CT ⎕DCT ⎕FR:',⍕⎕CT ⎕DCT ⎕FR
    ∇

    ∇ {r}←test_union_and_intersection;RunVariations;case;case2;caselist;ct;d1;d2;d3;data;data2;data_Hcmplx;data_Hdbl;data_Hfl;data_Sdbl;data_bool;data_char0;data_char1;data_char2;data_char3;data_char_ptr;data_cmplx;data_dbl;data_fl;data_i1;data_i2;data_i4;data_ptr;data_single_bool_0;data_single_bool_1;desc;fr;len;op;quadparams
      r←⍬
      case←⍬
      case2←⍬
      data_single_bool_0←∧/1 0 1 0                      ⍝ singleton boolean
      data_single_bool_1←∧/1 1 1 1                      ⍝ singleton boolean
      data_bool←1 0
      data_i1←100 ints 8
      data_i2←100 ints 16
      data_i4←100 ints 32
      :For len :In 8 16 32 64 128
          ⍎'data_i1_',⍕len'←len ints 8'
          ⍎'data_i2_',⍕len'←len ints 16'
          ⍎'data_i4_',⍕len'←len ints 32'
      :EndFor
      data_char0←⎕AV                                    ⍝ 82: DyalogAPL classic char set
      :If ~#.utils.isClassic
          data_char1←⎕UCS(100+⍳100)                     ⍝ 80: 8 bits character
          data_char2←⎕UCS(1000+⍳100)                    ⍝ 160: 16 bits character
          data_char3←⎕UCS(100000+⍳100)                  ⍝ 320: 32 bits character
          data_char_ptr←data_char1 data_char2 data_char3⍝ 326: Pointer (32-bit or 64-bit as appropriate)
      :EndIf
      data_ptr←data_i1 data_i2 data_i4                  ⍝ 326: Pointer (32-bit or 64-bit as appropriate)
      data_dbl←{⍵,-⍵}data_i4+0.1                        ⍝ 645: 64 bits Floating
      data_cmplx←{⍵,-⍵}(0J1×⍳100)+⌽⍳100                 ⍝ 1289: 128 bits Complex
      data_Hcmplx←{⍵,-⍵}(100000000000000J100000000000000×⍳20)                  ⍝ 1289 but larger numbers to test for CT value
      ⍝ Hdbl is 645 but larger numbers to test for CT value
      ⍝ intervals of 2 are chosen because CT for these numbers +1 and -1
      ⍝ come under the region of tolerant equality
      data_Hdbl←{⍵,-⍵}100000000000000+(2×⍳50)
     
      ⍝ This is needed for a case that can be hit if we have a lot of small numbers
      ⍝ which produce a hash collision
      ⍝ Occurrence: same.c.html#L1153
      data_Sdbl←{⍵,-⍵}(⍳500)÷1000
     
      ⍝ Hfl is 1287 but larger numbers to test for CT value
      ⍝ far intervals are chosen for non overlap
      ⍝ with region of tolerant equality
      ⎕FR←#.utils.fr_decf
      data_fl←{⍵,-⍵}data_i4+0.01                        ⍝ 1287: 128 bits Decimal
      data_Hfl←{⍵,-⍵}200000000000000000000000000000+(10000000000000000×⍳10)
      ⎕FR←#.utils.fr_dbl
     
      ⍝ Namespaces as args
      desc←testDesc
      r,←'Union (∪) ns'desc Assert((#)modelUnion(# ⎕SE))≡(#)∪(# ⎕SE)
      r,←'Intersection (∩) ns'desc Assert((#)modelIntersection(# ⎕SE))≡(#)∩(# ⎕SE)
     
      :For op :In '∪' '∩'
          :If op≡'∪'
              RunVariations←modelUnion #.testfns._RunVariationsWithModel_(⍎op)
          :Else
              RunVariations←modelIntersection #.testfns._RunVariationsWithModel_(⍎op)
          :EndIf
     
          :For ct :In 0 1 10 0.1
              (⎕CT ⎕DCT)←ct×#.utils.(ct_default dct_default)
              :For fr :In 1 2
                  ⎕FR←fr⊃#.utils.(fr_dbl fr_decf)
                  ⎕IO←1
     
                  quadparams←⎕CT ⎕DCT ⎕FR ⎕IO ⎕DIV
     
                  caselist←⎕NL ¯2
                  caselist←caselist⌿⍨{'data_'⊃⍤⍷⍵}¨caselist
     
                  :For case :In caselist
                      data←⍎case
                      desc←testDesc
                      :If (1287≡⎕DR data)∧645≡⎕FR
                      :Else
                          r,←({⍵≡'∪':'Union (∪)' ⋄ 'Intersection (∩)'}op)desc quadparams RunVariations data(data,data)
                          r,←({⍵≡'∪':'Union (∪) Hash1' ⋄ 'Intersection (∩) hash1'}op)desc quadparams RunVariations data(#.utils.hashArray data)
                      :EndIf
                      ⍝ General tests to test the basic rules of union
                      r,←'Union (∪) Gen1'desc Assert(≢data)≤≢data∪data                        ⍝ union returns a result that has less number of elements than the input
                      r,←'Intersection (∩) Gen1'desc Assert(≢data)≥≢data∩data                 ⍝ intersection returns a result that is exceding the number of elements than the input
     
                      r,←({⍵≡'∪':'Union (∪) Gen2' ⋄ 'Intersection (∩) Gen2'}op)desc Assert(⎕DR data)≡⎕DR data(⍎op)data                  ⍝ datatype of the data will not change under union or intersection
                      :For case2 :In caselist
                          data2←⍎case2
                          desc←testDesc
                          ⍝ remove very big numbers
                          :If (data≡data2)∨((1287∊⎕DR¨data data2)∧(645≡⎕FR))
                              :Continue
                          :EndIf
                          r,←({⍵≡'∪':'Union (∪) Cross' ⋄ 'Intersection (∩) Cross'}op)desc quadparams RunVariations data data2
                          r,←({⍵≡'∪':'Union (∪) Cross2' ⋄ 'Intersection (∩) Cross2'}op)desc quadparams RunVariations(data,data)data2
                          r,←({⍵≡'∪':'Union (∪) Cross3' ⋄ 'Intersection (∩) Cross3'}op)desc quadparams RunVariations data(data2,data2)
                          r,←({⍵≡'∪':'Union (∪) Cross4' ⋄ 'Intersection (∩) Cross4'}op)desc quadparams RunVariations(data,data)(data2,data2)
     
                          :For len :In 1 10 100 1000 10000
                              :If (~doSlowTests)∧(len≡10000)
                                  :Continue ⍝ Skip one case because it takes 30 minutes with len 10000
                              :EndIf
                              r,←({⍵≡'∪':'Union (∪) Cross5' ⋄ 'Intersection (∩) Cross5'}op)desc quadparams RunVariations((?len)⍴data,data2)((?len)⍴data2,data)
                          :EndFor
     
                          r,←({⍵≡'∪':'Union (∪) Hash2' ⋄ 'Intersection (∩) Hash2'}op)desc quadparams RunVariations(data,data)(#.utils.hashArray data2,data2)
     
                          ⍝ General tests to test the basic rules of union
                          r,←'Union (∪) CrossGen1'desc Assert((≢data)⌈≢data2)≤≢data∪data2                        ⍝ union returns a result that has less number of elements than the input
                          r,←'Intersection (∩) CrossGen1'desc Assert((≢data)⌈≢data2)≥≢data∩data2                 ⍝ intersection returns a result that is exceding the number of elements than the input
     
                          :If 1<(≢data)⌊≢data2
                              d1←data[?≢data]
                              d2←data[?≢(data~d1)]
                              d3←data2[?≢data2]
                              r,←({⍵≡'∪':'Union (∪) Cross5' ⋄ 'Intersection (∩) Cross5'}op)desc quadparams RunVariations d1 d2
                              r,←({⍵≡'∪':'Union (∪) Cross6' ⋄ 'Intersection (∩) Cross6'}op)desc quadparams RunVariations d1 data
                              r,←({⍵≡'∪':'Union (∪) Cross7' ⋄ 'Intersection (∩) Cross7'}op)desc quadparams RunVariations d1 data2
                              r,←({⍵≡'∪':'Union (∪) Cross8' ⋄ 'Intersection (∩) Cross8'}op)desc quadparams RunVariations d1 d3
                          :EndIf
     
                          ⍝ datatype of the data will not change under union
                          ⍝ 326 stays 326
                          ⍝ char + num becomes 326
                          ⍝ char + char and num + num becomes the greater sized type
                          r,←'Union (∪) CrossGen2'desc Assert((data){(⎕DR ⍺){326∊(⍺ ⍵):326 ⋄ 0∊≠0 2∊⍨10|(⍺ ⍵):⍺⌈⍵ ⋄ 326}⎕DR ⍵}(data2))≡⎕DR data∪data2
                      :EndFor
                  :EndFor
              :EndFor
          :EndFor
      :EndFor
    ∇
:EndNamespace
