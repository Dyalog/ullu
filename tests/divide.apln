:Namespace divide
    Assert←#.unittest.Assert
    stripToSameLen←#.utils.stripToSameLen

    model←{
        ⍺÷⍵
    }
    
    ∇ tRes←tData RunVariations exp
        (expectedR larg rarg)←exp
        (tID tCmt)←tData
        tRes←⍬

        ⍝ normal
        actualR←larg÷rarg
        tRes,←tData Assert expectedR≡actualR

        ⍝ empty
        actualRE←(0⍴larg)÷(0⍴rarg) ⍝ 0 in the shape means we have no elements in the array, i.e. it's empty.
        tRes,←('EmptyL',tID) tCmt Assert ⍬≡actualRE ⍝ empty array is expectedR

        ⍝ different shapes
        shape←?(?4)/4
        actualRS←(shape⍴larg)÷(shape⍴rarg)
        tRes,←('Multiple',tID) tCmt Assert (shape⍴expectedR)≡actualRS

        ⍝ different shapes with 0 in shape
        shapeW0←(0@(?(≢shape)))shape
        actualRSW0←(shapeW0⍴larg)÷(shapeW0⍴rarg)
        tRes,←('ShapeW0',tID) tCmt Assert (shapeW0⍴0) ≡ actualRSW0
    ∇

    ∇ r←test_divide
        ct_default←1E¯14
        dct_default←1E¯28
        fr_dbl←645
        fr_decf←1287
        div_0←0 ⍝ ⎕DIV values
        div_1←1

        ⍝ All data generated is unique
        bool←0 1                                      ⍝ 11: 1 bit Boolean type arrays
        i1←{⍵,-⍵}⍳120                               ⍝ 83: 8 bits signed integer
        char1←⎕UCS (100+⍳100)                         ⍝ 80: 8 bits character
        char2←⎕UCS (1000+⍳100)                        ⍝ 160: 16 bits character
        i2←{⍵,-⍵}10000+⍳100                           ⍝ 163: 16 bits signed integer
        char3←⎕UCS (100000+⍳100)                      ⍝ 320: 32 bits character
        i3←{⍵,-⍵}100000+⍳100                          ⍝ 323: 32 bits signed  integer
        ptr←(13↑⎕a) (13↓⎕a)                           ⍝ 326: Pointer (32-bit or 64-bit as appropriate)
        dbl←{⍵,-⍵}i3+0.1                              ⍝ 645: 64 bits Floating
        cmplx←{⍵,-⍵}(0J1×⍳100)+⌽⍳100                  ⍝ 1289: 128 bits Complex
        Hcmplx←{⍵,-⍵}(1E14J1E14×⍳20)                  ⍝ 1289 but larger numbers to test for CT value
        ⍝ Hdbl is 645 but larger numbers to test for CT value
        ⍝ intervals of 2 are chosen because CT for these numbers +1 and -1
        ⍝ come under the region of tolerant equality
        Hdbl←{⍵,-⍵}1E14+(2×⍳50)

        ⍝ This is needed for a case that can be hit if we have a lot of small numbers 
        ⍝ which produce a hash collision
        ⍝ Occurrence: same.c.html#L1153
        Sdbl←{⍵,-⍵}(⍳500)÷1000

        ⍝ Hfl is 1287 but larger numbers to test for CT value
        ⍝ far intervals are chosen for non overlap 
        ⍝ with region of tolerant equality
        ⎕FR←fr_decf
        fl←{⍵,-⍵}i3+0.01                              ⍝ 1287: 128 bits Decimal
        Hfl←{⍵,-⍵}2E29+(1E16×⍳10)
        ⎕FR←fr_dbl

        r←⍬
        testDesc←{'for ',case,{0∊⍴case2:'',⍵⋄' , ', case2,⍵},' & ⎕CT ⎕DCT:',⎕CT,⎕DCT, '& ⎕FR:', ⎕FR, '& ⎕DIV:',⎕DIV}

        case←⍬
        case2←⍬
        desc←testDesc⍬

        :For ct :In 0 1
            (⎕CT ⎕DCT)←ct × ct_default dct_default ⍝ set comparison tolerance

            :For fr :In 2 1
                ⎕FR←fr⊃fr_dbl fr_decf

                :For div :In 0 1
                    ⎕DIV←div
                    case←'independant'
                    desc←testDesc⍬

                    r,←'TI1' desc Assert (~div)≡0÷0
                    
                    :For case :In 'bool' 'i1' 'i2' 'i3' 'dbl' 'fl' 'cmplx' 'Hdbl' 'Sdbl' 'Hfl' 'Hcmplx'
                        data←⍎case
                        desc←testDesc⍬

                        ⍝ General tests to test the basic rules of unique
                        r,← 'TGen1' desc Assert (≢data)≡≢data÷data
                        r,← 'TGen2' desc Assert (⎕dr bool)≡⎕dr data ÷ data

                        d1←(data~0)[?≢data~0]
                        f←1
                        :Trap 11
                            _←d1÷0
                            f←div
                        :EndTrap
                        r,←'TI1' desc Assert f

                        :If case≢'bool'
                            r,← 'T1' desc RunVariations (1⍨¨data) data data
                            d1←data[?≢data]
                            d2←data[?≢(data~d1)]
                            r,← 'T2' desc RunVariations (d1 model d2) d1 d2 ⍝ generator func finds results on single element
                            r,← 'T3' desc RunVariations data data 1         ⍝ Identity
                        :EndIf

                        ⍝ Cross type tests
                        :For case2 :In 'i1' 'i2' 'i3' 'dbl' 'fl' 'cmplx' 'Hdbl' 'Hfl' 'Hcmplx'
                            data2←⍎case2
                            data data2←data stripToSameLen data2
                            desc←testDesc⍬
                            :If (case≡case2)
                                :Continue
                            :EndIf

                            r,← 'TGen3' desc Assert (({1289∊⎕dr data,data2:1289⋄⎕fr}⍬)≡⎕dr data ÷ data2)

                            r,← 'TCross1' desc RunVariations (data model data2) data data2
                            
                            f←1 ⍝ flag
                            :Trap 11 ⍝ 11: DOMAIN ERROR: Divide by zero
                                :If case≡'bool'
                                    _←data2÷data
                                :EndIf
                                f←div
                            :EndTrap
                            :If case≡'bool'
                                r,← 'TDomainE1' desc Assert f
                            :Else
                                r,← 'TCross2' desc RunVariations (data2 model data) data2 data
                            :EndIf

                            d1←data[?≢data]
                            d2←data2[?≢(data2~d1)]
                            r,← 'TCross3' desc RunVariations (d1 model d2) d1 d2 ⍝ generator func finds results on single element
                        :EndFor
                        case2←⍬ ⍝ dispose case2
                    :EndFor           
                :EndFor
            :EndFor
        :EndFor
    ∇

:EndNamespace