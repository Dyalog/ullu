:Namespace unique
    Assert←#.unittest.Assert

    genUnion←{⍺,(∧/⍺≢¨⍵)/⍵} ⍝ model function for union (X∪Y) (used to model unique)
    genUnique←{⍬≡⍴⍵:,⍵ ⋄ 1≥≢⍵:⍵ ⋄ ↑⊃genUnion⍨/⌽⊂¨⊂⍤¯1⊢1/⍵} ⍝ model function for unique

    ⍝ util functions
    shuffle←{⊂⍤?⍨∘≢⌷⍵}              ⍝ completely Random shuffle
    intertwine←{(⊂⍋∊⍳∘≢¨⍺ ⍵)⌷⍺⍪⍵}   ⍝ perfectly intertwine two arrays

    ∇ tRes←tData RunVariations exp ;actualR;actualRE;expectedR;expectedRE;ele;rarg;res;tID;tCmt;shape;actualRS;shapeW0;actualRSW0
        (expectedR rarg)←exp
        (tID tCmt)←tData
        tRes←⍬

        ⍝ normal
        actualR←∪rarg
        tRes,←tData Assert expectedR≡actualR

        ⍝ scalar
        ele←(?∘≢⊃⊢)rarg
        actualRS←∪ele
        tRes,←('Scalar',tID) tCmt Assert (,ele)≡actualRS

        ⍝ ⍝ empty
        actualRE←∪0⍴rarg ⍝ 0 in the shape means we have no elements in the array, i.e. it's empty.
        expectedRE←{(⎕DR ⍵)∊80 160 320:''⋄⍬}1⊃expectedR
        tRes,←('Empty',tID) tCmt Assert expectedRE≡actualRE ⍝ empty array is expectedR

        ⍝ ⍝ different shapes
        shape←?(?4)/4
        actualRS←∪(shape⍴rarg)
        expectedRS←genUnique shape⍴rarg ⍝ TODO: generator function does not work
        tRes,←('Multiple',tID) tCmt Assert expectedRS≡actualRS

        ⍝ different shapes with 0 in shape
        shapeW0←(0@(?(≢shape)))shape
        actualRSW0←∪shapeW0⍴rarg
        expectedRSW0←genUnique shapeW0⍴rarg
        tRes,←('ShapeW0',tID) tCmt Assert expectedRSW0 ≡ actualRSW0
    ∇

    ∇ r←test_unique ;ct_default;dct_default;fr_dbl;fr_decf;bool;i1;char1;char2;i2;char3;i3;ptr;dbl;cmplx;Hcmplx;Hdbl;⎕FR;⎕CT;⎕DCT;fl;Hfl;testDesc;case;case2;desc;ct;fr;data;data2;shuffledData;repetitions;shuffledRepeatedData
        ct_default←1E¯14
        dct_default←1E¯28
        fr_dbl←645
        fr_decf←1287

        ⍝ All data generated is unique
        bool←0 1                                      ⍝ 11: 1 bit Boolean type arrays
        i1←¯60+⍳120                                   ⍝ 83: 8 bits signed integer
        char1←⎕UCS (100+⍳100)                         ⍝ 80: 8 bits character
        char2←⎕UCS (1000+⍳100)                        ⍝ 160: 16 bits character
        i2←{⍵,-⍵}10000+⍳100                           ⍝ 163: 16 bits signed integer
        char3←⎕UCS (100000+⍳100)                      ⍝ 320: 32 bits character
        i3←{⍵,-⍵}100000+⍳100                          ⍝ 323: 32 bits signed  integer
        ptr←⎕A                                        ⍝ 326: Pointer (32-bit or 64-bit as appropriate)
        dbl←{⍵,-⍵}i3+0.1                              ⍝ 645: 64 bits Floating
        cmplx←{⍵,-⍵}(0J1×⍳100)+⌽⍳100                  ⍝ 1289: 128 bits Complex
        Hcmplx←{⍵,-⍵}(1E14J1E14×⍳20)                  ⍝ 1289 but larger numbers to test for CT value
        ⍝ Hdbl is 645 but larger numbers to test for CT value
        ⍝ intervals of 2 are chosen because CT for these numbers +1 and -1
        ⍝ come under the region of tolerant equality
        Hdbl←{⍵,-⍵}1E14+(2×⍳50)

        ⍝ This is needed for a case that can be hit if we have a lot of small numbers 
        ⍝ which produce a hash collision
        ⍝ Occurrence: same.c.html#L1153
        Sdbl←{⍵,-⍵}(⍳500)÷1000

        ⍝ Hfl is 1287 but larger numbers to test for CT value
        ⍝ far intervals are chosen for non overlap 
        ⍝ with region of tolerant equality
        ⎕FR←fr_decf
        fl←{⍵,-⍵}i3+0.01                              ⍝ 1287: 128 bits Decimal
        Hfl←{⍵,-⍵}2E29+(1E16×⍳10)
        ⎕FR←fr_dbl

        r←⍬
        testDesc←{'for ',case,{0∊⍴case2:'',⍵⋄' , ', case2,⍵},' & ⎕CT ⎕DCT:',⎕CT,⎕DCT, '& ⎕FR:', ⎕FR}

        case←⍬
        case2←⍬
        desc←testDesc⍬

        :For ct :In 0 1
            (⎕CT ⎕DCT)←ct × ct_default dct_default ⍝ set comparision tolerance

            :For fr :In 2 1
                ⎕FR←fr⊃fr_dbl fr_decf
                desc←testDesc⍬

                :For case :In 'bool' 'i1' 'i2' 'i3' 'char1' 'char2' 'char3' 'ptr' 'dbl' 'fl' 'cmplx' 'Hdbl' 'Sdbl' 'Hfl' 'Hcmplx'
                    data←⍎case
                    desc←testDesc⍬

                    :For case2 :In 'i1' 'i2' 'i3' 'char1' 'char2' 'char3' 'ptr' 'dbl' 'fl' 'cmplx' 'Hdbl' 'Hfl' 'Hcmplx'
                        data2←⍎case2
                        desc←testDesc⍬
                            :If (case≡case2) ∨ (case≡'bool') ⍝ skipping bool because of overlap with i1
                                 :Continue
                            :EndIf
                        r,← 'TCross1' desc RunVariations (data,data2) (data,data2) ⍝ all elements are concatenated
                        r,← 'TCross1' desc RunVariations (data intertwine data2) ((2/data) intertwine (2/data2)) ⍝ all elements are doubled & perfectly intertwined
                    :EndFor

                    case2←⍬ ⍝ dispose case2
                    desc←testDesc⍬

                    r,← 'T1' desc RunVariations data data                               ⍝ all elements of data are indexed
                    r,← 'T2' desc RunVariations data (2/data)                           ⍝ all elements of data are repeated sequentially
                    r,← 'T3' desc RunVariations data (data intertwine data)             ⍝ all elements are perfectly intertwined

                    shuffledData←↑shuffle data
                    r,← 'T4' desc RunVariations (genUnique shuffledData) shuffledData   ⍝ shuffle data without creating duplicate data

                    repetitions←?6
                    shuffledRepeatedData←↑shuffle repetitions/data
                    r,← 'T5' desc RunVariations (genUnique shuffledRepeatedData) shuffledRepeatedData  ⍝ duplicate and shuffle

                    ⍝ tests with comparision tolerance
                    :If ~(⎕DR data) ∊ 80 160 320 326 ⍝ non-numeric are skipped                  
                        d1←(data~0)[?≢data~0] ⍝ 0 interferes with the calculations of almostd1S and almostd1B hence it is removed
                        almostd1S←d1×1-fr⊃1E¯2×ct_default dct_default ⍝ infinitesimally close to d1 but smaller
                        almostd1B←d1×1+fr⊃1E¯1×ct_default dct_default ⍝ infinitesimally close to d1 but bigger
                        :If ct ⍝ tolerant
                            :If (⊂data)∊Hdbl Hfl Hcmplx ⍝ bigger numbers
                                ⍝ Hdbl=Hdbl+1 with default CT, but not for DECF
                                r,← 'CTDefault1' desc Assert (((,d1)≡∪d1,d1+1) ∨ ((fr=2) ∧ case≡'Hdbl'))
                            :Else ⍝ other than bigger numbers
                                r,← 'CTDefault2' desc Assert ((d1,d1+1)≡∪d1,d1+1)               ⍝ not tolerantly equal for other numbers
                                r,← 'CTDefaultAlmostS' desc Assert ((,d1)≡∪d1,almostd1S)        ⍝ d1 and almostd1S are tolerantly equal
                                r,← 'CTDefaultAlmostB' desc Assert ((,d1)≡∪d1,almostd1B)        ⍝ d1 and almostd1B are tolerantly equal
                            :EndIf
                        :Else ⍝ exact
                            ⍝ ⍝ d≠d+1 for all numeric types
                            r,← 'CTZero' desc Assert (((d1,d1+1)≡∪d1,d1+1) ∨ ((fr=1) ∧ case≡'Hfl'))
                            r,← 'CTZeroAlmostS' desc Assert (((d1,almostd1S)≡∪d1,almostd1S) ∨ ((fr=2) ∧ 1289≡⎕dr d1)) ⍝ due to limited precision of IEEE 745 doubles cmplx is ignored with ⎕fr←1287
                            r,← 'CTZeroAlmostB' desc Assert (((d1,almostd1B)≡∪d1,almostd1B) ∨ ((fr=2) ∧ 1289≡⎕dr d1)) ⍝ due to limited precision of IEEE 745 doubles cmplx is ignored with ⎕fr←1287
                        :EndIf
                    :EndIf
                :EndFor

                ⍝ Independant tests
                case←'independant'
                case2←⍬
                desc←testDesc⍬

                ⍝ Generating singleton scalar boolean using ∧/1 0 1 0 and ∧/1 1 1 1
                ⍝ 2/ to generate a bool vector that gives one result element when ∪ is applied
                r,←'TboolI1' desc Assert (,0)≡∪2/∧/1 0 1 0
                r,←'TboolI2' desc Assert (,1)≡∪2/∧/1 1 1 1

                ⍝ The special case can be hit if we have two 8 bit int numbers in the input: a & b, and a is b×1-⎕CT. 
                ⍝ That means, that when we get to element b in the loop, we will find element a and hit the case.
                ⍝ Occurrence: same.c.html#L1152
                d←i1[?≢i1]
                r,←'TCTI1' desc Assert (,d-({fr-1:⎕dct⋄⎕ct}⍬))≡(∪ (d-({fr-1:⎕dct⋄⎕ct}⍬)) d)
            :EndFor
        :EndFor
    ∇

:EndNamespace
