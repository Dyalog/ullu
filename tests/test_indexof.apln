:Namespace test_indexof
    Assert←#.unittest.Assert

        ⍝ Run Variations of each test with normal, empty and multiple shaped data
    ∇ tRes←tData RunVariations exp ;actualR;actualRE;expectedR;left;right;res;tID;tCmt;lshape;lshapeW0;rshape;x;actualRM
        (expectedR left right)←exp
        (tID tCmt)←tData
        tRes←⍬

        ⍝ normal
        actualR←left⍳right
        tRes,←tData Assert expectedR≡actualR

        ⍝ empty left
        ⍝ actualRE←(0⍴⊂left)∊right ⍝ generating empty array from right
        ⍝ tRes,←('Empty',tID) tCmt Assert ⍬≡actualRE ⍝ empty array is expectedR

        ⍝ ⍝ empty right
        ⍝ actualRE←left∊(0⍴⊂right) ⍝ generating empty array from right
        ⍝ tRes,←('Empty',tID) tCmt Assert (0×expectedR)≡actualRE ⍝ all 0s in expectedR is the new expected result

        ⍝ ⍝ different shapes
        ⍝ ⍝ for ANY array lshape, and for any rightshape where (≢right)≤×/rshape
        ⍝ ⍝ the condition guarantees that (rshape⍴right) will create an array
        ⍝ ⍝ which contains ALL the elements of right, possibly more than once
        ⍝ lshape←?4/4
        ⍝ ⍝ randomized shape which has ≤7 elements and each elements is ≤12 and satisfies above condition
        ⍝ rshape←{(×/(x←(?4)?⍤/?12))>≢right:x ⋄ ∇⍵}⍬
        ⍝ actualRM←(lshape⍴left)∊(rshape⍴right)
        ⍝ tRes,←('Shape',tID) tCmt Assert (lshape⍴expectedR) ≡ actualRM

        ⍝ ⍝ different shapes with 0 in shape
        ⍝ lshapeW0←(0@(?4))lshape
        ⍝ actualRM←(lshapeW0⍴left)∊(rshape⍴right)
        ⍝ tRes,←('ShapeW0',tID) tCmt Assert (lshapeW0⍴0) ≡ actualRM
    ∇
    
    ∇ r←Test_indexof
        ct_default←1E¯14
        dct_default←1E¯28
        fr_dbl←645
        fr_decf←1287
        
        bool←0 1                                      ⍝ 11: 1 bit Boolean type arrays
        i1←¯60+⍳120                                   ⍝ 83: 8 bits signed integer
        char1←⎕UCS ⍳255                               ⍝ 80: 8 bits character
        char2←⎕UCS (1000+⍳100)                        ⍝ 160: 16 bits character
        i2←{⍵,-⍵}10000+⍳100                           ⍝ 163: 16 bits signed integer
        char3←⎕UCS (100000+⍳100)                      ⍝ 320: 32 bits character
        i3←{⍵,-⍵}100000+⍳100                          ⍝ 323: 32 bits signed  integer
        ptr←2,/⎕A                                     ⍝ 326: Pointer (32-bit or 64-bit as appropriate)
        dbl←{⍵,-⍵}i3+0.1                              ⍝ 645: 64 bits Floating
        cmplx←{⍵,-⍵}(0J1×⍳100)+⌽⍳100                  ⍝ 1289: 128 bits Complex
        ⍝ Hdbl is 645 but higher order to test for CT value
        ⍝ intervals of 2 are chosen because CT for these numbers +1 and -1
        ⍝ come under the region of tolerant equality
        Hdbl←{⍵,-⍵}1E14+(2×⍳50)
        ⍝ Hfl is 1287 but higher order to test for CT value
        ⍝ far intervals are chosen for non overlap 
        ⍝ with region of tolerant equality
        ⎕FR←fr_decf
        fl←{⍵,-⍵}i3+0.01                              ⍝ 1287: 128 bits Decimal
        Hfl←{⍵,-⍵}2E29+(1E16×⍳10)
        ⎕FR←fr_dbl 
        Hcmplx←{⍵,-⍵}(1E14J1E14×⍳20)                  ⍝ 1289 but higher order to test for CT value

        r←⍬
        testDesc←{'for ',case,{0∊⍴case2:'',⍵⋄' , ', case2,⍵},' & ⎕CT ⎕DCT:',⎕CT,⎕DCT, '& ⎕FR:', ⎕FR}

        :For ct :In 1 0 
            (⎕CT ⎕DCT)←ct × ct_default dct_default ⍝ set comparision tolerance

            :For fr :In 1 2
                ⎕FR←fr⊃fr_dbl fr_decf
                case←⍬
                case2←⍬
                desc←testDesc⍬
                r,← 'T1' desc RunVariations (4 1 3 2 6) (2 4 3 1 4) (1 2 3 4 5)
                case2←⍬
            :EndFor
        :EndFor
    ∇
:EndNamespace