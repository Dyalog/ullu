:Namespace test_membership
    assert←#.unittest.assert

    ⍝ This section of testcases are categorised based on the ⎕DR model.
    ⍝ Read more: https://help.dyalog.com/latest/#Language/System%20Functions/Data%20Representation%20Monadic.htm
    :Section Testing for all datatypes
        ∇ r←Test_DR ;w;n;r;data;type;bool;i1;char1;char2;i2;char3;i3;ptr;dbl;fl;cmplx
            bool←0 1                                ⍝ 11: 1 bit Boolean type arrays
            i1←¯60+⍳120                             ⍝ 83: 8 bits signed integer
            char1←⎕UCS ⍳255                         ⍝ 80: 8 bits character
            char2←⎕UCS (256+⍳10000)                 ⍝ 160: 16 bits character
            i2←{⍵,-⍵}10000+⍳1000                    ⍝ 163: 16 bits signed integer
            char3←⎕UCS (10256+⍳100000)              ⍝ 320: 32 bits character
            i3←{⍵,-⍵}100000+⍳1000                   ⍝ 323: 32 bits signed  integer
            ptr←2,/⎕A                               ⍝ 326: Pointer (32-bit or 64-bit as appropriate)
            dbl←{⍵,-⍵}i3+0.1                        ⍝ 645: 64 bits Floating
            ⎕FR←1287 ⋄ fl←{⍵,-⍵}i3+0.01 ⋄ ⎕FR←645   ⍝ 1287: 128 bits Decimal
            cmplx←{⍵,-⍵}(0J1×⍳10000)+⌽⍳10000       ⍝ 1289: 128 bits Complex

            r←⍬
            :For data :In bool i1 i2 i3 char1 char2 char3 ptr dbl fl cmplx
                :If 11≠type←⎕DR data
                    ⍝ Cross DR testing
                    :For data2 :In i1 i2 i3 char1 char2 char3 ptr dbl fl cmplx
                        :If (data≡data2)
                            r,←assert (((≢data)⍴1) ≡ (data∊data2)) 'tcross0' ('for ⎕DR', (⎕DR data), 'and', (⎕DR data2))
                            :Continue
                        :EndIf
                        r,←assert (((≢data)⍴0) ≡ (data∊data2)) 'tcross1' ('for ⎕DR', (⎕DR data), 'and', (⎕DR data2)) ⍝ no match, all return 0
                        r,←assert (((≢data2)⍴0) ≡ (data2∊data)) 'tcross2' ('for ⎕DR', (⎕DR data), 'and', (⎕DR data2)) ⍝ no match, all return 0
                        r,←assert (((≢data)⍴1) ≡ (data∊data,data2)) 'tcross3' ('for ⎕DR', (⎕DR data), 'and', (⎕DR data2)) ⍝ first data match, returns 1
                        r,←assert ((((≢data)⍴1),((≢data2)⍴0))≡((data,data2)∊data)) 'tcross4' ('for ⎕DR', (⎕DR data), 'and', (⎕DR data2)) ⍝ data match, data2 no match
                    :EndFor
                    r,←assert ((data[?≢data])∊data) 't1' ('for ⎕DR', ⎕DR data)                  ⍝ random element is found
                    r,←assert (((((≢data)-1)⍴0), 1)≡data∊(¯1↑data)) 't2' ('for ⎕DR', ⎕DR data)  ⍝ All elements return 0 except last
                    r,←assert (((≢data)⍴1)≡data∊data) 't3' ('for ⎕DR', ⎕DR data)                ⍝ all elements return 1
                    :If (80≠type←⎕DR data)∧(160≠type←⎕DR data)∧(320≠type←⎕DR data)              ⍝ ⎕UCS conversion reqd for char
                        :If 326=type←⎕DR data                                                   ⍝ not relevant for ptr
                            :continue
                        :EndIf
                        ⍝ todo: try to get rid of special case
                        r,←assert (~((⊃data)-1)∊data) 't4.1' ('for ⎕DR', ⎕DR data)              ⍝ element outside set is not found
                    :Else
                        r,←assert (~(⎕UCS((⎕UCS(⊃data))-1))∊data) 't4.2' ('for ⎕DR', ⎕DR data)  ⍝ element outside set is not found
                    :EndIf
                    ⍝ Todo: add more tests
                :Else ⍝ Booleans need special tests
                    ⍝ Boolean tests here because the domain is so small
                    r,←assert (0∊0) 'tb1' ('for ⎕DR', ⎕DR data)
                    r,←assert (~0∊1) 'tb2' ('for ⎕DR', ⎕DR data)
                    r,←assert (1 1≡bool∊bool) 'tb3' ('for ⎕DR', ⎕DR bool)
                    :For data2 :In i1 i2 i3 char1 char2 char3 ptr dbl fl cmplx ⍝ bool requires separate cross tests because of overlap with i1
                        :If (83≠type←⎕DR data2)
                                r,←assert (((≢bool)⍴0) ≡ (bool∊data2)) 'tcrossBool' ('for ⎕DR', (⎕DR bool), 'and', (⎕DR data2)) ⍝ All elements return 0
                                r,←assert (((≢data2)⍴0) ≡ (data2∊bool)) 'tcrossBool' ('for ⎕DR', (⎕DR bool), 'and', (⎕DR data2)) ⍝ All elements return 0
                            :Else
                                r,←assert (((≢bool)⍴1) ≡ (bool∊data2)) 'tcrossBool' ('for ⎕DR', (⎕DR bool), 'and', (⎕DR data2)) ⍝ All elements return 1
                                r,←assert (((⊣,(⌽⊣))((1↓((≢i1)÷2)⍴0),1)) ≡ (data2∊bool)) 'tcrossBool' ('for ⎕DR', (⎕DR bool), 'and', (⎕DR data2)) ⍝ overlaping 0 1 returns 1
                        :EndIf
                    :EndFor
                :EndIf
            :EndFor
        ∇
    :EndSection

    ⍝ Tests based upon ⎕CT value
    ⍝ Read more: https://help.dyalog.com/latest/#Language/System%20Functions/ct.htm
    :Section Based on CT and DCT
        ∇ r←Test_CT ;type;dbl;fl;cmplx;data
            ⍝ dbl←1E14
            ⍝ ⎕FR←1287
            ⍝     fl←1E28
            ⍝ ⎕FR←645
            ⍝     r,←assert (1≡(fl∊(fl+1))) 'dct1' (⎕DR fl)

            ⍝ ⎕CT←1E¯14 ⍝ The default, ignores differences beyond the 14th digit or so
            ⍝ ⎕DCT←1E¯28
            
            
            ⍝ dbl←1E15                        ⍝ 645: 64 bits Floating
            ⍝ ⎕FR←1287
            ⍝ fl←1E28
            ⍝ ⎕FR←645   ⍝ 1287: 128 bits Decimal
            ⍝ cmplx←{⍵,-⍵}((0J1E28+0.5)×⍳10000)+⌽⍳10000⍝ 1289: 128 bits Complex
            r←⍬

            ⍝ :For data :In dbl fl
            ⍝     :If 645≠type←⎕DR data
            ⍝         ⎕DCT←1E¯28
            ⍝         r,←assert (1≡(data[?≢data]∊data∘+1)) 'ct3' ('for ⎕DR', ⎕DR data)

            ⍝         ⎕DCT←0
            ⍝         r,←assert (0≡(data[?≢data]∊data+1)) 'ct4' ('for ⎕DR', ⎕DR data)
                        
            ⍝     :Else
            ⍝         ⎕CT←1E¯14 ⍝ The default, ignores differences beyond the 14th digit or so
            ⍝         ⎕DCT←1E¯28
            ⍝         r,←assert (1≡(data∊data+1)) 'ct1' ('for ⎕DR', ⎕DR data)

            ⍝         ⎕CT←0 ⍝ Exact comparisons, like in C or most other languages
            ⍝         ⎕DCT←0
            ⍝         r,←assert (0≡(data∊data+1)) 'ct2' ('for ⎕DR', ⎕DR data)
            ⍝     :EndIf
            ⍝ :EndFor

            ⍝ ⎕FR←1287
            ⍝ fl←1E100
            ⍝ ⎕FR←645   ⍝ 1287: 128 bits Decimal
            dbl←1E14


            ⎕CT←1E¯14 ⍝ The default, ignores differences beyond the 14th digit or so
            ⎕DCT←1E¯28

            r,←assert (1≡(dbl∊dbl+1)) 'ct1' (⎕DR dbl)
            
            ⎕FR←1287
                fl←1E28
                r,←assert (1≡(fl∊(fl+1))) 'dct1' (⎕DR fl)
            ⎕FR←645
            r,←assert (1≡(1E16J1∊(1E16J1+1))) 'dct2' (⎕DR 1E29J1)

            ⎕CT←0 ⍝ Exact comparisons, like in C or most other languages
            ⎕DCT←0
            r,←assert (0≡(dbl∊dbl+1)) 'ct2' (⎕DR dbl)
            ⎕FR←1287
                ⍝ fl←1E28
                r,←assert (0≡(fl∊(fl+1))) 'dct3' (⎕DR fl)
            
            ⎕FR←645
                r,←assert (0≡(1E15J1∊(1E15J1+1))) 'dct4' (⎕DR 1E16J1)
            ⎕CT←1E¯14 ⍝ The default, ignores differences beyond the 14th digit or so
            ⎕DCT←1E¯28
        ∇
    :EndSection

:EndNamespace
